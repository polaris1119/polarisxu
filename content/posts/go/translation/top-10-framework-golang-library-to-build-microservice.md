---
title: "构建微服务的 10 大 Go 框架/库"
date: 2021-03-02T22:00:00+08:00
toc: true
isCJKLanguage: true
tags: 
  - Go
  - Echo
  - 微服务
---

![](imgs/10-top-framework.png)

现在，很多开源库都支持构建应用程序。我应该向你推荐一些库，它们可以帮助启动具有简单设计、干净代码和良好性能的项目。

## 01 CLI 命令(spf13/cobra)

![](imgs/cobra.png)

你想要构建一些 CLI 命令吗？

> Cobra 既是一个用于创建强大的现代 CLI 应用程序的库，也是一个用于生成应用程序和命令文件的程序。

我使用这个库来管理命令应用程序，执行运行程序，初始化配置，并启动 Rest API。

基于 cobra 的应用组织结构：

```bash
├── app
│ ├── main.go
│ ├── cmd
│ └── root.go
```

app/main.go 的代码如下：

```go
package main
import (
   "app/cmd"
)
func main() {
   cmd.Execute()
}
```

app/cmd/root.go 代码如下：

```go
package cmd
var rootCmd = &cobra.Command{
   Use:   "hugo",
   Short: "Hugo is a very fast static site generator",
   Long: `A Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at http://hugo.spf13.com`,
   Run: func(cmd *cobra.Command, args []string) {
      // Do Stuff Here
   },
}
func Execute() {
   if err := rootCmd.Execute(); err != nil {
      fmt.Println(err)
      os.Exit(1)
   }
}
```

项目地址：<https://github.com/spf13/cobra>。

## 02 配置读取器(spf13/viper)

![](imgs/viper.png)

> Viper 是 Go 应用程序的完整配置解决方案。

Viper 支持以下格式配置：

- JSON
- TOML
- YAML
- HCL
- INI
- envfile
- Java properties config files

例如 config/config.toml：

```toml
address="localhost"
port="9090"
```

响应操作的文件 config.go：

```go
func ReadConfig() {
   viper.SetConfigName("config/config.toml")
   viper.SetConfigType("toml")
   err := viper.ReadInConfig()
   if err != nil {
      panic(fmt.Errorf("Fatal error config file: %s \n", err))
   }
}
```

然后在 main.go 中使用 config 的值：

```go
func main() {
   address := viper.Get("address")
   port := viper.Get("port")
   fmt.Printf("address: %s", address)
   fmt.Printf("port: %s", port)
}
```

项目地址：<https://github.com/spf13/viper>。

## 03 Web 框架(labstack/echo)

![](imgs/echo.png)

> Echo 是一个高性能、极简主义的 Go Web 框架。

**安装**

```bash
// go get github.com/labstack/echo/{version}
go get github.com/labstack/echo/v4
```

**例子**

```go
package main

import (
  "net/http"
  "github.com/labstack/echo/v4"
  "github.com/labstack/echo/v4/middleware"
)

func main() {
  // Echo instance
  e := echo.New()

  // Middleware
  e.Use(middleware.Logger())
  e.Use(middleware.Recover())

  // Routes
  e.GET("/", hello)

  // Start server
  e.Logger.Fatal(e.Start(":1323"))
}

// Handler
func hello(c echo.Context) error {
  return c.String(http.StatusOK, "Hello, World!")
}
```

项目地址：<https://github.com/labstack/echo>。

## 04 依赖注入(uber-go/fx)

![](imgs/uber-fx.png)

我发现这个库非常有用，你不需要生成任何东西。只有代码。非常模块化和清晰的层次。

> 一个依赖注入的 Go 应用框架。

```go
func main() {
	fx.New(injectModule()).Run()
}

func injectModule() fx.Option {
	return fx.Options(
		fx.Provide( 
		     NewTimeOutContext, 
		     NewDbConn, 
		),
		repository.Module, 
		service.Module, 
		outbound.Module, 
		server.Module, 
		controller.Module,
	)
}
```

项目地址：<https://github.com/uber-go/fx>。

## 04 Swagger Generator, UI 和 Validation

![](imgs/swagger.png)

在 swagger 部分，我必须使用不同的 3 个库，因为我没有找到 1 个库同时包含这个 3 个库功能的。如果你有推荐，请评论告知。

### a、Swagger generator (swaggo/swag)

> Swag 将 Go 注释转换为 Swagger Documentation 2.0。

我们为流行的 [Go Webb 框架](https://github.com/swaggo/swag#supported-web-frameworks)创建了各种各样的插件。这允许你快速集成一个现有的 Go 项目（使用 Swagger UI）。

支持的 Web 框架：

- gin
- echo
- buffalo
- net/http

Swag 已经处理了你那些 swagger 文件。所以你不再需要写 swagger.yml 或 swagger.json。你需要做的只是编写注释。看一个例子：

```go
// @title Blueprint Swagger API
// @version 1.0
// @description Swagger API for Golang Project Blueprint.
// @termsOfService http://swagger.io/terms/
// @contact.name API Support
// @contact.email martin7.heinz@gmail.com
// @license.name MIT
// @license.url https://github.com/MartinHeinz/go-project-blueprint/blob/master/LICENSE
// @BasePath /api/v1
func main() {
    ...
    r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
    ...
}
```

项目地址：<https://github.com/swaggo/swag>。

### b、Swagger UI (swaggo/echo-swagger)

因为我正在使用 echo，所以我为 swagger 选择了这个 user interface。

使用示例：

```go
package main
import (
	"github.com/labstack/echo/v4"
	"github.com/swaggo/echo-swagger"
	_ "github.com/swaggo/echo-swagger/example/docs" // docs is generated by Swag CLI, you have to import it.
)
// @title Swagger Example API
// @version 1.0
// @description This is a sample server Petstore server.
// @termsOfService http://swagger.io/terms/
// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io
// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @host petstore.swagger.io
// @BasePath /v2
func main() {
	e := echo.New()
	e.GET("/swagger/*", echoSwagger.WrapHandler)
	e.Logger.Fatal(e.Start(":1323"))
}
```

项目地址：<https://github.com/swaggo/echo-swagger>。

### c、Swagger validation (go-swagger/go-swagger)

> 这个包包含了 Swagger 2.0（又名 [OpenAPI 2.0](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md)）的 golang 实现: 它知道如何序列化和反序列化 Swagger 规范。

安装：

```bash
go get github.com/go-swagger/go-swagger/cmd/swagger
```

运行以验证：

```bash
swagger validate api/docs/swagger.yaml
```

输出如下：

```bash
2021/01/30 22:47:01 
The swagger spec at "api/docs/swagger.yaml" is valid against swagger specification 2.0
```

项目地址：<https://github.com/go-swagger/go-swagger>。

## 06、自定义 Logger (sirupsen/logrus)

![](imgs/logrus.png)

> Logrus 是 Go (golang)的结构化 Logger，完全兼容标准库 Log。

例子：

```go
package main

import (
  log "github.com/sirupsen/logrus"
)

func main() {
  log.WithFields(log.Fields{
    "animal": "walrus",
  }).Info("A walrus appears")
}
```

项目地址：<https://github.com/sirupsen/logrus>。

## 07、Mock 生成器 (vektra/mockery)

> 一个 Mock 代码自动生成器

安装：

```bash
go get github.com/vektra/mockery/v2/.../
```

生成 mock：

```bash
./bin/mockery --all
```

输出：

![](imgs/mock-01.png)

![](imgs/mock-02.png)

项目地址：<https://github.com/vektra/mockery>。

## 08、Migrate (golang-migrate/migrate)

> 用 Go 编写的数据库迁移工具。作为 [CLI](https://github.com/golang-migrate/migrate#cli-usage) 使用或作为[库](https://github.com/golang-migrate/migrate#use-in-your-go-project)导入。

支持如下数据库：

- PostgreSQL
- Redshift
- Ql
- Cassandra
- SQLite (todo #165)
- SQLCipher
- MySQL/ MariaDB
- Neo4j
- MongoDB
- CrateDB (todo #170)
- Shell (todo #171)
- Google Cloud Spanner
- CockroachDB
- ClickHouse
- Firebird
- MS SQL Server

安装：

```bash
$ go get -u -d github.com/golang-migrate/migrate/cmd/migrate
```

创建迁移文件：

```bash
migrate create -ext sql -dir database/migrations -seq create_user
```

运行升级版本：

```bash
migrate -database "mysql://user:pass@tcp(localhost:3600)/user" -path=database/migrations up
```

降版本：

```bash
migrate -database "mysql://user:pass@tcp(localhost:3600)/user" -path=database/migrations down
```

项目地址：<https://github.com/golang-migrate/migrate>。

## 09、Messaging (NSQ)

![](imgs/nsq.png)

NSQ 拓扑：

![](imgs/nsq01.png)

NSQ 组件：

1. nsqlookupd (daemon manage topologies / routes)
2. nsqd (daemon manage receives, queues, and delivers messages)
3. nsqadmin (default Web UI of nsq)

基于 docker-compose 示例： (nsqlookupd，nsqd，nsqadmin)

```yaml
version: '3'
services:
nsqlookupd:
image: nsqio/nsq
command: /nsqlookupd
ports:
- "4160:4160"
- "4161:4161"
nsqd:
image: nsqio/nsq
command: /nsqd --lookupd-tcp-address=nsqlookupd:4160
depends_on:
- nsqlookupd
ports:
- "4150:4150"
- "4151:4151"
nsqadmin:
image: nsqio/nsq
command: /nsqadmin --lookupd-http-address=nsqlookupd:4161
depends_on:
- nsqlookupd
ports:
- "4171:4171"
```

执行：

```go
To run docker:
$ docker-compose up -d
or if use name (docker-compose-nsq.yml):
$ docker-compose -f docker-compose-nsq.yml up -d
To check container docker:
$ docker-compose ps
To see logs:
$ docker-compose logs
To check nsq web ui: (assuming port is 32770)
$ curl http://127.0.0.1:32770/ping
```

Go 代码目录：

```bash
Create Folder:
├── consume
│   └── consume.go
└── publish
    └── publish.go
```

consume.go 代码：

```go
package main
import (
    "log"
    "sync"
    "github.com/nsqio/go-nsq"
)
func main() {
    wg := &sync.WaitGroup{}
    wg.Add(1)
    decodeConfig := nsq.NewConfig()
    c, err := nsq.NewConsumer("My_NSQ_Topic", "My_NSQ_Channel", decodeConfig)
    if err != nil {
    		log.Panic("Could not create consumer")
    }
    c.AddHandler(nsq.HandlerFunc(func(message *nsq.Message) error {
        log.Println("NSQ message received:")
        log.Println(string(message.Body))
    		return nil
    }))
    err = c.ConnectToNSQD("127.0.0.1:4150")
    if err != nil {
    		log.Panic("Could not connect")
    }
    log.Println("Awaiting messages from NSQ topic \"My NSQ Topic\"...")
    wg.Wait()
}
```

运行 consume.go：

```bash
$ go run consume/consume.go
```

publish.go 代码：

```go
package main
import (
    "log"
    "github.com/nsqio/go-nsq"
)
func main() {
    config := nsq.NewConfig()
    p, err := nsq.NewProducer("127.0.0.1:4150", config)
    if err != nil {
   		 log.Panic(err)
    }
    err = p.Publish("My_NSQ_Topic", []byte("sample NSQ message"))
    if err != nil {
    		log.Panic(err)
    }
}
```

运行 publish：

```bash
$ go run publish/publish.go
```

项目地址：<https://github.com/nsqio/go-nsq>。

## 10、SQL (jmoiron/sqlx)

> sqlx 是一个库，它为 go 的标准 database/sql 库提供了一组扩展。

我喜欢的 sqlx 是因为它们可以 scan 结构！使用简单。

StrucScan 的例子：

```go
place := Place{}
rows, err := db.Queryx("SELECT * FROM place")
for rows.Next() {
    err := rows.StructScan(&place)
    if err != nil {
      	log.Fatalln(err)
    } 
    fmt.Printf("%#v\n", place)
}
```

项目地址：<https://github.com/jmoiron/sqlx>。

## 11、附加的一些库

1）Go routine grouping (sync/errgroup)：<https://pkg.go.dev/golang.org/x/sync/errgroup>

2）Fluent SQL generation for golang (Masterminds/squirrel)：<https://github.com/Masterminds/squirrel>

3）Golang Linter (golangci/golangci-lint)：<https://github.com/golangci/golangci-lint>

4）Circuit Breaker (gojek/heimdall)：<https://github.com/gojek/heimdall>

5）Go tool generate tags (fatih/gomodifytags)：<https://github.com/fatih/gomodifytags>

## 12、总结

要构建应用程序，我们应该知道有什么功能，特别是如果我们是团队协作，建议使用可读性强的代码，这样在成为遗留代码之前（也许 5-10 年之后） ，代码可以更容易维护。

构建应用程序的三个关键：

1. 简单设计（项目结构和依赖关系）
2. Clean Code (可读性和可维护性)
3. Modular（模块化） (Solid & flexible skeleton)

为了封装所有这些库，我有一个模板或框架项目，其设计简单，代码清晰。看看这个：<https://github.com/kecci/goscription>。

以上就是我常用的 10 大 Go 框架/库和一些附加库。

我希望你喜欢我的推荐，如果你有其他的推荐，请留言！

> 原文链接：<https://keccikun.medium.com/top-10-framework-golang-library-to-build-microservice-391a2bb4c2cb>
>
> 作者：Kecci Kun
>
> 编译：polarisxu


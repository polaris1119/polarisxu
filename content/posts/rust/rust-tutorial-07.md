---
title: "Rust 劝退系列 07：流程控制"
date: 2021-05-25T22:30:00+08:00
toc: true
isCJKLanguage: true
tags: 
  - rust
---

大家好，我是站长 polarisxu。

这是 Rust 劝退系列的第 7 个教程，探讨 Rust 中的流程控制。注意，跟其他语言一样，Rust 中有条件、循环，但没有 switch，而是有 match 模式匹配。

## 01 运算符

开始讲解流程控制之前，先补充一个知识点，那就是 Rust 的运算符。

Rust 支持算术运算符、关系运算符、逻辑运算符和位运算符 4 种，它们和其他语言没有什么不同，因此不细讲了，只提醒一点：Rust 中没有自增（++）和自减运算符（--）。

> Go 中 `++` 或 `--` 是语句，只有一种形式：后缀，即 i++；而 C 等语言支持前缀和后缀，如 i++、++i。Rust 干脆全没有。

吐槽：自增和自减运算符，有时候挺好用的，Rust 为啥不支持呢？！（难道因为没有常规的 for 循环，所以不需要？）

## 02 语句和表达式

为什么专门介绍语句和表达式？！

上文提到，Go 中的自增或自减是语句而不是表达式，这有什么不同呢？

很多语言对语句和表达式基本不会特意区分、强调，所以很多人也不会在意这两者有什么不同。但在 Rust 中，还是很有必要区分它们的。

实际上，Rust 中的语法可以分为两大类：语句（Statement）和表达式（Expression）。语句是指要执行的一些操作和产生副作用的表达式；而表达式主要用于计算求值。

语句通常分为声明语句和表达式语句。像声明各种语言项，如变量、常量、结构体、函数等，都是声明语句：

```rust
let a = 1;
const PI: i32 = 3.14;
```

而表达式语句，指的是以分号结尾的表达式，一般会涉及到将多个表达式组合为语句。

《Rust 编程之道》上说，Rust 中的表达式一般分为「位置表达式」和「值表达式」，概念太多，容易劝退，直接按照其他语言的叫法：左值和右值。

> 之所以都用表达式的说法，是因为 Rust 中一切皆表达式。

罗里吧嗦讲一堆，似乎没啥用。知道有这么回事即可。只需要记住 Rust 中一切皆表达式即可。

## 03 条件表达式

知道为什么要强调「表达式」了吗？一般语言中都叫：条件语句，但 Rust 中却是条件表达式。

首先，条件表达式的语法和其他语言的条件语句类似，支持 if、else if、else 等，但它和 Go 中类似，条件默认都不需要括号。但因为是表达式，所以它有返回值，而 Rust 是强类型语言，因此返回值的类型必须确定。比如以下代码是能正常编译的：

```rust
fn testif() -> &'static str {
    let name = "polarisxu";
    if name == "polarisxu" {
        "Welcome"
    } else {
        "Forbidden"
    }
}
```

看不懂没关系。我们只关注 if-else 部分。

在块表达式里（由 `{}` 包围），直接一个字符串字面值（这是值表达式），连分号都没有。Rust 没有分号和 Go 中的没有分号意义是不一样的。

- Go 语句以分号结尾，分号推荐不写，编译器会自动补上；
- Rust 语句必须手动加分号，如果不加分号，那是一个表达式。

一切皆表达式，大括号包围起来的是块表达式，那块表达式的值是什么？它的值是里面一系列表达式中最后一个表达式的值。

所以，上面的代码，无论是执行到 if 还是 else，整个 if 表达式的值的类型是字符串。所以，以上代码可以改为这样：

```rust
fn testif() -> &'static str {
    let name = "polarisxu";
    let result = if name == "polarisxu" {
        "Welcome"
    } else {
        "Forbidden"
    };

    hello
}
```

我们将 if 表达式的结果保存在 result 变量中，注意 if 表达式大括号最后的分号，这种情况，分号不能省略。

因此，在 if 表达式中，各个分支表达式最终的结果类型必须一致，否则编译不通过。这也是为什么 Rust 不支持三元操作符 ?: 的原因。

if 是表达式有它的好处。在 Go 语言中，经常会写类似这样的代码：

```go
var result string
if name == "polarisxu" {
  result = "Welcome"
} else {
  result = "Forbidden"
}
```

而 Rust 的代码，result 少写了很多次。但需要注意各分支结果类型的一致性。

if 表达式可以这么用，其他流程控制表达式也可以这么用。

**特别说明一点**。如果块表达式的最后一个表达式是语句，比如：

```rust
fn testif() -> &'static str {
    let name = "polarisxu";
    if name == "polarisxu" {
        "Welcome";
    } else {
        "forbidden";
    }
}
```

这时编译会报错：mismatched types。

因为函数要求返回值类型是 &str，而函数体最后返回的类型是空。这个空，在其他语言中一般是没有返回值，或者是 void。但在 Rust 中，这个空是前面介绍类型时介绍过的「unit」类型，即 ()，该类型有唯一的值，也是 ()。

所以，我们可以去掉函数的返回值，或者返回 ()：

```rust
fn testif() -> () {
    let name = "polarisxu";
    if name == "polarisxu" {
        "Welcome";
    } else {
        "forbidden";
    }
}
```

很另类，有木有？！

## 04 循环表达式

Rust 中包含三种循环表达式：while、loop 和 for…in。其用法和其他编程语言相应的语句类似。（注意，Go 中只有 for 一种循环语句）

loop 循环比较特殊，一般语言中没有，它其实就是 `while true {}`，相当于 Go 中的 `for {}`。不得不说，还是 Go 简单呀！

而 while 循环，相当于 Go 中的 `for condition {}`，condition 为 true 时，执行循环体。

你发现没，循环搞这么复杂，竟然没有其他语言中普通的 for 循环？因为 for…in 可以搞定。

比如 Go 中的 `for i := 0; i < 10; i++`，在 Rust 中是这样的：`for i in 0..10 {}`。来个简单的例子，从 1 加到 100：

```rust
let mut sum = 0;
for i in 1..=100 {
  sum += i;
}
println!("1+2+..+100={}", sum);
```

> 小细节：1..10 表示范围 [1, 10)，而 1..=10 表示范围 [1, 10]

最后，和其他语言一样，循环支持 continue 和 break 语句。

## 05 小结

Rust 中一切皆表达式，当某个地方需要一个表达式，但却是一个语句时，编译器会自动补上单元值，即 ()，这算是一个特殊的表达式。

虽然控制结构，if、循环等都是表达式，为了不搞特殊化（毕竟大家习惯很多其他语言，特殊化可能容易把自己搞迷糊），建议大家尽量别把它们当表达式看待，很其他语言一样正常写，该有分号的加分号。

不过，如果是 Go 程序员写 Rust，很可能忘记分号。而 Rust 中，有时候有分号和没有分号都能编译，但意思可能变了，这个要特别注意。（PHPer 表示，经常在 PHP 和 Go 之间切换时，分号的问题很纠结，有木有？！）

控制流程中的模式匹配，下节再讲！